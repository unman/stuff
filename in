#!/bin/bash
# Check inputs
check_port(){
if ! [ "$1" -eq "$1" >& /dev/null ];then
  return 1
else
	if [ $1 -lt 65536 ]; then
		return 0
	else
		return 1
	fi
fi
}

get_handle(){
local my_handle=$( qvm-run -q -u root -p $1 " nft -a list table $2|awk 'BEGIN{c=0} /$3/{c++; if (c==$4) print \$NF}' " )
echo $my_handle
}

tunnel(){
declare -a my_netvms=("${!1}")
declare -a my_ips=("${!2}")
declare -i numhops
numhops=${#my_ips[@]}
local i=1
iface="eth0"
numhops=$((numhops-1))
while [ $i -ne $numhops ]
do
	qvm-run -q -u root ${my_netvms[$i]} " nft list table nat|grep ' $proto dport $portnum dnat to ${my_ips[$i-1]}'"
	if [ $? -eq 0 ]; then
		echo "Are rules already set?"
		exit
	else
		qvm-run -q -u root ${my_netvms[$i]} -- nft insert rule nat PR-QBS meta iifname $iface $proto dport $portnum dnat to ${my_ips[$i-1]}
		local handle=$( get_handle ${my_netvms[$i]} filter related,established 2 )
		qvm-run -q -u root ${my_netvms[$i]} -- nft add rule filter FORWARD position $handle meta iifname $iface ip daddr ${my_ips[$i-1]} $proto dport $portnum ct state new accept
	fi
	((i++))
done
qvm-run -q -u root ${my_netvms[$i]} " nft list table nat|grep ' $proto dport $portnum dnat to ${my_ips[$i-1]}'"
if [ $? -eq 0 ]; then
	echo "Are rules already set?"
	exit
else
	qvm-run -q -u root ${my_netvms[$i]} -- nft insert rule nat PR-QBS meta iifname $external_iface $proto dport $portnum dnat to ${my_ips[$i-1]}
	qvm-run -q -u root ${my_netvms[$i]} -- nft insert rule filter FORWARD meta iifname $external_iface ip daddr ${my_ips[$i-1]} $proto dport $portnum ct state new accept
fi
}

if [ $# -ne 3 ]; then
  echo "Please specify target qube, tcp or udp, and target port"
  exit
fi
qvm-check -q $1 2>/dev/null
if [ "$?" -ne 0 ];then
  echo "$1 is not the name of any qube"
  exit
else
	qube_name=$1
fi
if [ "$2" != "tcp" -a "$2" != "udp" ]; then
  echo "Specify tcp or udp"
  exit
else
	proto=$2
fi
check_port $3
if [ $? -ne 0 ]; then
  if !  grep -q -w ^$3\  /etc/services  ; then
    echo "Specify usable port number"
    exit
  else
    portnum=$( getent services $3 |awk '{split($2,a,"/");print a[1]}')
    check_port $portnum
    if [ $? -ne 0 ]; then
      echo "Specify usable port number"
      exit
    fi
  fi
else
	portnum=$3
fi

# Get all netvms
declare -a netvms
declare -a ips
declare -a external_ips
hop=0
netvms[$hop]=$qube_name
IFS='|' read -r netvms[$hop+1] ips[$hop] <<< $(qvm-ls $qube_name --raw-data -O netvm,IP)
while [ ${netvms[hop+1]} != "-" ]
do
  ((hop++))
  IFS='|' read -r netvms[$hop+1] ips[$hop] <<< $(qvm-ls ${netvms[$hop]} --raw-data -O netvm,IP)
done
if [ $hop -eq 0 ]; then
	echo "$qube_name is not network connected"
  echo "Cannot set up a tunnel"
	exit
fi

# Check last hop has external IP address 
readarray -t external_ips < <( qvm-run -p ${netvms[$hop]} "ip -4 -o a|grep -wv 'lo\|vif[0-9]*.*'"|awk '{print $2,$4}')
#readarray -t external_ips < <( qvm-run -p ${netvms[$hop]} "ip -4 -o a|grep -wv 'vif[0-9]'"|awk '{print $2,$4}')
num_ifs=${#external_ips[@]}
if [ $num_ifs -eq 1 ]; then
  interface=0
elif [ $num_ifs -gt 1 ]; then
  echo "${netvms[$hop-1]} has more than 1 external interface"
  echo "Which one do you want to use?"
  for i in $(seq $num_ifs)
  do
    echo "$i. ${external_ips[$i-1]}"
  done
  read interface
  if ! [ "$interface" -eq "$interface" ] 2> /dev/null; then
    echo "No such interface"
    exit
  elif [ $interface -gt $num_ifs ] || [ $interface -lt 1 ]; then
    echo "No such interface"
    exit
  fi
  ((interface--))
else
  echo "${netvms[$hop]} does not have an external interface"
  echo "Cannot set up a tunnel"
  exit
fi
external_ip=${external_ips[$interface]}
external_iface="${external_ip%[[:space:]]*}"
ip="${external_ip#*[0-9]}"
ip="${ip%%/*}"
ips[$hop]=$ip

# Create tunnel
qvm-run -q -u root $qube_name  "nft list table filter|grep '$proto dport $portnum accept' "
if [ $? -eq 0 ]; then
	echo "Input rule in $qube_name already exists"
	echo "Please check configuration - exiting now."
else
	handle=$( get_handle $qube_name filter related,established 1)
	qvm-run -q -u root $qube_name -- nft add rule filter INPUT position $handle iifname eth0 $proto dport $portnum accept
	tunnel netvms[@] ips[@]
fi
